// Generated by CoffeeScript 1.12.6
let NEXT_UNIQUE_ID = 1;
let slice = [].slice
export let Util = {
  defaults: function (obj, opts, defaults) {
    var prop, results;
    for (prop in opts) {
      if (obj[prop] == null) {
        obj[prop] = opts[prop];
      }
    }
    results = [];
    for (prop in defaults) {
      if (obj[prop] == null) {
        results.push(obj[prop] = defaults[prop]);
      } else {
        results.push(void 0);
      }
    }
    return results;
  },
  arraysEqual: function (a, b) {
    var i, len1, o, val;
    if (!a.length === b.length) {
      return false;
    }
    for (i = o = 0, len1 = a.length; o < len1; i = ++o) {
      val = a[i];
      if (!(val === b[i])) {
        return false;
      }
    }
    return true;
  },
  uniqueId: function (prefix = '') {
    if (prefix == null) {
      prefix = '';
    }
    return prefix + NEXT_UNIQUE_ID++;
  },
  element: function (elementOrString) {
    if (typeof elementOrString === 'string') {
      return document.getElementById(elementOrString);
    } else {
      return elementOrString;
    }
  }
};

export class Events$Dispatcher {

  constructor() {
  }

  on(type, listener) {
    var i, name;
    i = type.indexOf('.');
    name = '';
    if (i > 0) {
      name = type.substring(i + 1);
      type = type.substring(0, i);
    }
    if (this[type] != null) {
      this[type].on(name, listener);
    }
    return this;
  };



}

function Events$Event() {
  var event;
  event = function (...args) {
    var l, name, ref, results;
    ref = event.listenerMap;
    results = [];
    for (name in ref) {
      l = ref[name];
      if (l != null) {
        results.push(l.apply(this, args));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  event.listenerMap = {};
  event.on = function (name, listener) {
    delete event.listenerMap[name];
    if (listener != null) {
      return event.listenerMap[name] = listener;
    }
  };
  return event;
};
export let Events = {
  dispatch: function (...args) {
    var arg, dispatch, len1, o;
    dispatch = new Events.Dispatcher();
    for (o = 0, len1 = args.length; o < len1; o++) {
      arg = args[o];
      dispatch[arg] = Events.Event();
    }
    return dispatch;
  },
  Dispatcher: Events$Dispatcher,
  Event: Events$Event
};



let ARRAY_POOL = new Array(16);

let IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

let TRANSPOSE_INDICES = [0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15];

export class Matrix {
  baked: any
  m: any
  constructor(m1 = null) {
    if (this.m == null) {
      this.m = IDENTITY.slice();
    }
    this.baked = IDENTITY;
  }

  copy() {
    return new Matrix(this.m.slice());
  };

  matrix(m) {
    var c, i, j, o, u;
    c = ARRAY_POOL;
    for (j = o = 0; o < 4; j = ++o) {
      for (i = u = 0; u < 16; i = u += 4) {
        c[i + j] = m[i] * this.m[j] + m[i + 1] * this.m[4 + j] + m[i + 2] * this.m[8 + j] + m[i + 3] * this.m[12 + j];
      }
    }
    ARRAY_POOL = this.m;
    this.m = c;
    return this;
  };

  reset() {
    this.m = this.baked.slice();
    return this;
  };

  bake(m) {
    this.baked = (m != null ? m : this.m).slice();
    return this;
  };

  multiply(b) {
    return this.matrix(b.m);
  };

  transpose() {
    var c, i, len1, o, ti;
    c = ARRAY_POOL;
    for (i = o = 0, len1 = TRANSPOSE_INDICES.length; o < len1; i = ++o) {
      ti = TRANSPOSE_INDICES[i];
      c[i] = this.m[ti];
    }
    ARRAY_POOL = this.m;
    this.m = c;
    return this;
  };

  rotx(theta) {
    var ct, rm, st;
    ct = Math.cos(theta);
    st = Math.sin(theta);
    rm = [1, 0, 0, 0, 0, ct, -st, 0, 0, st, ct, 0, 0, 0, 0, 1];
    return this.matrix(rm);
  };

  roty(theta) {
    var ct, rm, st;
    ct = Math.cos(theta);
    st = Math.sin(theta);
    rm = [ct, 0, st, 0, 0, 1, 0, 0, -st, 0, ct, 0, 0, 0, 0, 1];
    return this.matrix(rm);
  };

  rotz(theta) {
    var ct, rm, st;
    ct = Math.cos(theta);
    st = Math.sin(theta);
    rm = [ct, -st, 0, 0, st, ct, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    return this.matrix(rm);
  };

  translate(x = 0, y = 0, z = 0) {
    var rm;
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    rm = [1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1];
    return this.matrix(rm);
  };

  scale(sx = 1, sy = null, sz = null) {
    var rm;
    if (sx == null) {
      sx = 1;
    }
    if (sy == null) {
      sy = sx;
    }
    if (sz == null) {
      sz = sy;
    }
    rm = [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1];
    return this.matrix(rm);
  };



}

export function M(m = null) {
  return new Matrix(m);
};

export let Matrices = {
  identity: function () {
    return M();
  },
  flipX: function () {
    return M().scale(-1, 1, 1);
  },
  flipY: function () {
    return M().scale(1, -1, 1);
  },
  flipZ: function () {
    return M().scale(1, 1, -1);
  }
};

export class Transformable extends Matrix{
  baked: any
  m: any
  constructor() {
    super();
    var fn, len1, method, o, ref;
    this.m = new Matrix();
    this.baked = IDENTITY;
    for (o = 0, len1 = ref.length; o < len1; o++) {
      method = ref[o];
      fn(method);
    }
  }

  transform(m) {
    this.m.multiply(m);
    return this;
  };



}
let POINT_POOL;
export class Point {
  x: any
  w: any
  z: any
  y: any
  constructor(x4 = 0, y4 = 0, z4 = 0, w1 = 1) {
    this.x = x4 != null ? x4 : 0;
    this.y = y4 != null ? y4 : 0;
    this.z = z4 != null ? z4 : 0;
    this.w = w1 != null ? w1 : 1;
  }

  copy() {
    return new Point(this.x, this.y, this.z, this.w);
  };

  set(p) {
    this.x = p.x;
    this.y = p.y;
    this.z = p.z;
    this.w = p.w;
    return this;
  };

  add(q) {
    this.x += q.x;
    this.y += q.y;
    this.z += q.z;
    return this;
  };

  subtract(q) {
    this.x -= q.x;
    this.y -= q.y;
    this.z -= q.z;
    return this;
  };

  translate(x, y, z) {
    this.x += x;
    this.y += y;
    this.z += z;
    return this;
  };

  multiply(n) {
    this.x *= n;
    this.y *= n;
    this.z *= n;
    return this;
  };

  divide(n) {
    this.x /= n;
    this.y /= n;
    this.z /= n;
    return this;
  };

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  };

  normalize() {
    var n;
    n = this.magnitude();
    if (n === 0) {
      this.set(Points.Z());
    } else {
      this.divide(n);
    }
    return this;
  };

  perpendicular() {
    var mag, n;
    n = this.copy().cross(Points.Z());
    mag = n.magnitude();
    if (mag !== 0) {
      return n.divide(mag);
    }
    return this.copy().cross(Points.X()).normalize();
  };

  transform(matrix) {
    var r;
    r = POINT_POOL;
    r.x = this.x * matrix.m[0] + this.y * matrix.m[1] + this.z * matrix.m[2] + this.w * matrix.m[3];
    r.y = this.x * matrix.m[4] + this.y * matrix.m[5] + this.z * matrix.m[6] + this.w * matrix.m[7];
    r.z = this.x * matrix.m[8] + this.y * matrix.m[9] + this.z * matrix.m[10] + this.w * matrix.m[11];
    r.w = this.x * matrix.m[12] + this.y * matrix.m[13] + this.z * matrix.m[14] + this.w * matrix.m[15];
    this.set(r);
    return this;
  };

  magnitudeSquared() {
    return this.dot(this);
  };

  magnitude() {
    return Math.sqrt(this.magnitudeSquared());
  };

  dot(q) {
    return this.x * q.x + this.y * q.y + this.z * q.z;
  };

  cross(q) {
    var r;
    r = POINT_POOL;
    r.x = this.y * q.z - this.z * q.y;
    r.y = this.z * q.x - this.x * q.z;
    r.z = this.x * q.y - this.y * q.x;
    this.set(r);
    return this;
  };



}

export function P(x = 0, y = 0, z = 0, w = 1) {
  return new Point(x, y, z, w);
};

POINT_POOL = P();

export let Points = {
  X: function () {
    return P(1, 0, 0);
  },
  Y: function () {
    return P(0, 1, 0);
  },
  Z: function () {
    return P(0, 0, 1);
  },
  ZERO: function () {
    return P(0, 0, 0);
  }
};

export class Quaternion {
  static pixelsPerRadian = 150;

  static xyToTransform(x, y) {
    var quatX, quatY;
    quatX = Quaternion.pointAngle(Points.Y(), x / Quaternion.pixelsPerRadian);
    quatY = Quaternion.pointAngle(Points.X(), y / Quaternion.pixelsPerRadian);
    return quatX.multiply(quatY).toMatrix();
  };

  static axisAngle(x, y, z, angleRads) {
    var scale, w;
    scale = Math.sin(angleRads / 2.0);
    w = Math.cos(angleRads / 2.0);
    return new Quaternion(scale * x, scale * y, scale * z, w);
  };

  static pointAngle(p, angleRads) {
    var scale, w;
    scale = Math.sin(angleRads / 2.0);
    w = Math.cos(angleRads / 2.0);
    return new Quaternion(scale * p.x, scale * p.y, scale * p.z, w);
  };

  q: any
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.q = P(x, y, z, w);
  }

  multiply(q) {
    var r, result;
    r = P();
    r.w = this.q.w * q.q.w - this.q.x * q.q.x - this.q.y * q.q.y - this.q.z * q.q.z;
    r.x = this.q.w * q.q.x + this.q.x * q.q.w + this.q.y * q.q.z - this.q.z * q.q.y;
    r.y = this.q.w * q.q.y + this.q.y * q.q.w + this.q.z * q.q.x - this.q.x * q.q.z;
    r.z = this.q.w * q.q.z + this.q.z * q.q.w + this.q.x * q.q.y - this.q.y * q.q.x;
    result = new Quaternion();
    result.q = r;
    return result;
  };

  toMatrix() {
    var m;
    m = new Array(16);
    m[0] = 1.0 - 2.0 * (this.q.y * this.q.y + this.q.z * this.q.z);
    m[1] = 2.0 * (this.q.x * this.q.y - this.q.w * this.q.z);
    m[2] = 2.0 * (this.q.x * this.q.z + this.q.w * this.q.y);
    m[3] = 0.0;
    m[4] = 2.0 * (this.q.x * this.q.y + this.q.w * this.q.z);
    m[5] = 1.0 - 2.0 * (this.q.x * this.q.x + this.q.z * this.q.z);
    m[6] = 2.0 * (this.q.y * this.q.z - this.q.w * this.q.x);
    m[7] = 0.0;
    m[8] = 2.0 * (this.q.x * this.q.z - this.q.w * this.q.y);
    m[9] = 2.0 * (this.q.y * this.q.z + this.q.w * this.q.x);
    m[10] = 1.0 - 2.0 * (this.q.x * this.q.x + this.q.y * this.q.y);
    m[11] = 0.0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1.0;
    return M(m);
  };



}

export class Bounds {
  static points(points) {
    var box, len1, o, p;
    box = new Bounds();
    for (o = 0, len1 = points.length; o < len1; o++) {
      p = points[o];
      box.add(p);
    }
    return box;
  };

  static xywh(x, y, w, h) {
    //return Boundses.xyzwhd(x, y, 0, w, h, 0);
  };

  static xyzwhd(x, y, z, w, h, d) {
    var box;
    box = new Bounds();
    box.add(P(x, y, z));
    box.add(P(x + w, y + h, z + d));
    return box;
  };

  max: any
  min: any
  constructor() {
    this.min = null;
    this.max = null;
  }

  copy() {
    var box, ref, ref1;
    box = new Bounds();
    box.min = (ref = this.min) != null ? ref.copy() : void 0;
    box.max = (ref1 = this.max) != null ? ref1.copy() : void 0;
    return box;
  };

  add(p) {
    if (!((this.min != null) && (this.max != null))) {
      this.min = p.copy();
      this.max = p.copy();
    } else {
      this.min.x = Math.min(this.min.x, p.x);
      this.min.y = Math.min(this.min.y, p.y);
      this.min.z = Math.min(this.min.z, p.z);
      this.max.x = Math.max(this.max.x, p.x);
      this.max.y = Math.max(this.max.y, p.y);
      this.max.z = Math.max(this.max.z, p.z);
    }
    return this;
  };

  valid() {
    return (this.min != null) && (this.max != null);
  };

  intersect(box) {
    if (!this.valid() || !box.valid()) {
      this.min = null;
      this.max = null;
    } else {
      this.min = P(Math.max(this.min.x, box.min.x), Math.max(this.min.y, box.min.y), Math.max(this.min.z, box.min.z));
      this.max = P(Math.min(this.max.x, box.max.x), Math.min(this.max.y, box.max.y), Math.min(this.max.z, box.max.z));
      if (this.min.x > this.max.x || this.min.y > this.max.y || this.min.z > this.max.z) {
        this.min = null;
        this.max = null;
      }
    }
    return this;
  };

  pad(x, y, z) {
    var p;
    if (this.valid()) {
      if (y == null) {
        y = x;
      }
      if (z == null) {
        z = y;
      }
      p = P(x, y, z);
      this.min.subtract(p);
      this.max.add(p);
    }
    return this;
  };

  reset() {
    this.min = null;
    this.max = null;
    return this;
  };

  contains(p) {
    if (!this.valid()) {
      return false;
    } else if (this.min.x > p.x || this.max.x < p.x) {
      return false;
    } else if (this.min.y > p.y || this.max.y < p.y) {
      return false;
    } else if (this.min.z > p.z || this.max.z < p.z) {
      return false;
    } else {
      return true;
    }
  };

  center() {
    return P(this.minX() + this.width() / 2, this.minY() + this.height() / 2, this.minZ() + this.depth() / 2);
  };

  width() {
    return this.maxX() - this.minX();
  };

  height() {
    return this.maxY() - this.minY();
  };

  depth() {
    return this.maxZ() - this.minZ();
  };

  minX() {
    var ref, ref1;
    return (ref = (ref1 = this.min) != null ? ref1.x : void 0) != null ? ref : 0;
  };

  minY() {
    var ref, ref1;
    return (ref = (ref1 = this.min) != null ? ref1.y : void 0) != null ? ref : 0;
  };

  minZ() {
    var ref, ref1;
    return (ref = (ref1 = this.min) != null ? ref1.z : void 0) != null ? ref : 0;
  };

  maxX() {
    var ref, ref1;
    return (ref = (ref1 = this.max) != null ? ref1.x : void 0) != null ? ref : 0;
  };

  maxY() {
    var ref, ref1;
    return (ref = (ref1 = this.max) != null ? ref1.y : void 0) != null ? ref : 0;
  };

  maxZ() {
    var ref, ref1;
    return (ref = (ref1 = this.max) != null ? ref1.z : void 0) != null ? ref : 0;
  };



}

export class Color {
  b: any
  g: any
  a: any
  r: any
  constructor(r1 = 0, g1 = 0, b1 = 0, a1 = 0xFF) {
    this.r = r1 != null ? r1 : 0;
    this.g = g1 != null ? g1 : 0;
    this.b = b1 != null ? b1 : 0;
    this.a = a1 != null ? a1 : 0xFF;
  }

  copy() {
    return new Color(this.r, this.g, this.b, this.a);
  };

  scale(n) {
    this.r *= n;
    this.g *= n;
    this.b *= n;
    return this;
  };

  offset(n) {
    this.r += n;
    this.g += n;
    this.b += n;
    return this;
  };

  clamp(min, max) {
    if (min == null) {
      min = 0;
    }
    if (max == null) {
      max = 0xFF;
    }
    this.r = Math.min(max, Math.max(min, this.r));
    this.g = Math.min(max, Math.max(min, this.g));
    this.b = Math.min(max, Math.max(min, this.b));
    return this;
  };

  minChannels(c) {
    this.r = Math.min(c.r, this.r);
    this.g = Math.min(c.g, this.g);
    this.b = Math.min(c.b, this.b);
    return this;
  };

  addChannels(c) {
    this.r += c.r;
    this.g += c.g;
    this.b += c.b;
    return this;
  };

  multiplyChannels(c) {
    this.r *= c.r;
    this.g *= c.g;
    this.b *= c.b;
    return this;
  };

  hex() {
    var c;
    c = (this.r << 16 | this.g << 8 | this.b).toString(16);
    while (c.length < 6) {
      c = '0' + c;
    }
    return '#' + c;
  };

  style() {
    return "rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
  };



}

export let Colors = {
  CSS_RGBA_STRING_REGEX: /rgb(a)?\(([0-9.]+),([0-9.]+),*([0-9.]+)(,([0-9.]+))?\)/,
  parse: function (str) {
    var a, m;
    if (str.charAt(0) === '#' && str.length === 7) {
      return Colors.hex(str);
    } else if (str.indexOf('rgb') === 0) {
      m = Colors.CSS_RGBA_STRING_REGEX.exec(str);
      if (m == null) {
        return Colors.black();
      }
      a = m[6] != null ? Math.round(parseFloat(m[6]) * 0xFF) : void 0;
      return new Color(parseFloat(m[2]), parseFloat(m[3]), parseFloat(m[4]), a);
    } else {
      return Colors.black();
    }
  },
  rgb: function (r, g, b, a) {
    if (a == null) {
      a = 255;
    }
    return new Color(r, g, b, a);
  },
  hex: function (hex) {
    if (hex.charAt(0) === '#') {
      hex = hex.substring(1);
    }
    return new Color(parseInt(hex.substring(0, 2), 16), parseInt(hex.substring(2, 4), 16), parseInt(hex.substring(4, 6), 16));
  },
  hsl: function (h, s, l, a = 1) {
    var b, g, hue2rgb, p, q, r;
    if (a == null) {
      a = 1;
    }
    r = g = b = 0;
    if (s === 0) {
      r = g = b = l;
    } else {
      hue2rgb = function (p, q, t) {
        if (t < 0) {
          t += 1;
        } else if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p + (q - p) * 6 * t;
        } else if (t < 1 / 2) {
          return q;
        } else if (t < 2 / 3) {
          return p + (q - p) * (2 / 3 - t) * 6;
        } else {
          return p;
        }
      };
      q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return new Color(r * 255, g * 255, b * 255, a * 255);
  },
  randomSurfaces: function (shape, sat, lit) {
    var len1, o, ref, results, surface;
    if (sat == null) {
      sat = 0.5;
    }
    if (lit == null) {
      lit = 0.4;
    }
    ref = shape.surfaces;
    results = [];
    for (o = 0, len1 = ref.length; o < len1; o++) {
      surface = ref[o];
      results.push(surface.fill(Colors.hsl(Math.random(), sat, lit)));
    }
    return results;
  },
  randomSurfaces2: function (shape, drift, sat, lit) {
    var hue, len1, o, ref, results, surface;
    if (drift == null) {
      drift = 0.03;
    }
    if (sat == null) {
      sat = 0.5;
    }
    if (lit == null) {
      lit = 0.4;
    }
    hue = Math.random();
    ref = shape.surfaces;
    results = [];
    for (o = 0, len1 = ref.length; o < len1; o++) {
      surface = ref[o];
      hue += (Math.random() - 0.5) * drift;
      while (hue < 0) {
        hue += 1;
      }
      while (hue > 1) {
        hue -= 1;
      }
      results.push(surface.fill(Colors.hsl(hue, 0.5, 0.4)));
    }
    return results;
  },
  randomShape: function (shape, sat, lit) {
    if (sat == null) {
      sat = 0.5;
    }
    if (lit == null) {
      lit = 0.4;
    }
    return shape.fill(new Material(Colors.hsl(Math.random(), sat, lit)));
  },
  black: function () {
    return this.hex('#000000');
  },
  white: function () {
    return this.hex('#FFFFFF');
  },
  gray: function () {
    return this.hex('#888888');
  }
};

export function C(r = 0, g = 0, b = 0, a = 0xFF) {
  return new Color(r, g, b, a);
};

export class Material {
  static create(value) {
    if (value instanceof Material) {
      return value;
    } else if (value instanceof Color) {
      return new Material(value);
    } else if (typeof value === 'string') {
      return new Material(Colors.parse(value));
    } else {
      return new Material();
    }
  };

  defaults = {
    color: Colors.gray(),
    metallic: false,
    specularColor: Colors.white(),
    specularExponent: 15,
    shader: null
  };
  color: Color
  shader: any
  constructor(color1 = Colors.gray(), options = {}) {
    this.color = color1;
    if (options == null) {
      options = {};
    }

    Util.defaults(this, options, this.defaults);
  }

  render(lights, shader, renderData) {
    var color, ref, renderShader;
    renderShader = (ref = this.shader) != null ? ref : shader;
    color = renderShader.shade(lights, renderData, this);
    color.a = this.color.a;
    return color;
  };



}

export class Light extends Transformable {
  defaults = {
    point: P(),
    color: Colors.white(),
    intensity: 0.01,
    normal: P(1, -1, -1).normalize(),
    enabled: true
  };

  intensity: any
  type: any
  color: any
  colorIntensity: any
  id: any
  constructor(type1, options) {
    super();
    this.type = type1;
    Util.defaults(this, options, this.defaults);
    this.id = Util.uniqueId('l');
  }

  render() {
    return this.colorIntensity = this.color.copy().scale(this.intensity);
  };



}

export let Lights = {
  point: function (opts) {
    return new Light('point', opts);
  },
  directional: function (opts) {
    return new Light('directional', opts);
  },
  ambient: function (opts) {
    return new Light('ambient', opts);
  }
};

let EYE_NORMAL = Points.Z();

export let ShaderUtils = {
  applyDiffuse: function (c, light, lightNormal, surfaceNormal, material) {
    var dot;
    dot = lightNormal.dot(surfaceNormal);
    if (dot > 0) {
      return c.addChannels(light.colorIntensity.copy().scale(dot));
    }
  },
  applyDiffuseAndSpecular: function (c, light, lightNormal, surfaceNormal, material) {
    var dot, reflectionNormal, specularColor, specularIntensity;
    dot = lightNormal.dot(surfaceNormal);
    if (dot > 0) {
      c.addChannels(light.colorIntensity.copy().scale(dot));
      reflectionNormal = surfaceNormal.copy().multiply(dot * 2).subtract(lightNormal);
      specularIntensity = Math.pow(0.5 + reflectionNormal.dot(EYE_NORMAL), material.specularExponent);
      specularColor = material.specularColor.copy().scale(specularIntensity * light.intensity / 255.0);
      return c.addChannels(specularColor);
    }
  },
  applyAmbient: function (c, light) {
    return c.addChannels(light.colorIntensity);
  }
};

export class Shader {

  constructor() { }

  shade(lights, renderModel, material) { };



}

export class Phong extends Shader {

  constructor() {
    super();
  }

  shade(lights, renderModel, material) {
    var c, len1, light, lightNormal, o;
    c = new Color();
    for (o = 0, len1 = lights.length; o < len1; o++) {
      light = lights[o];
      switch (light.type) {
        case 'point':
          lightNormal = light.point.copy().subtract(renderModel.barycenter).normalize();
          ShaderUtils.applyDiffuseAndSpecular(c, light, lightNormal, renderModel.normal, material);
          break;
        case 'directional':
          ShaderUtils.applyDiffuseAndSpecular(c, light, light.normal, renderModel.normal, material);
          break;
        case 'ambient':
          ShaderUtils.applyAmbient(c, light);
      }
    }
    c.multiplyChannels(material.color);
    if (material.metallic) {
      c.minChannels(material.specularColor);
    }
    c.clamp(0, 0xFF);
    return c;
  };
}

export class DiffusePhong extends Shader {
  constructor() {
    super();
  }

  shade(lights, renderModel, material) {
    var c, len1, light, lightNormal, o;
    c = new Color();
    for (o = 0, len1 = lights.length; o < len1; o++) {
      light = lights[o];
      switch (light.type) {
        case 'point':
          lightNormal = light.point.copy().subtract(renderModel.barycenter).normalize();
          ShaderUtils.applyDiffuse(c, light, lightNormal, renderModel.normal, material);
          break;
        case 'directional':
          ShaderUtils.applyDiffuse(c, light, light.normal, renderModel.normal, material);
          break;
        case 'ambient':
          ShaderUtils.applyAmbient(c, light);
      }
    }
    c.multiplyChannels(material.color).clamp(0, 0xFF);
    return c;
  };
}

export class Ambient extends Shader {
  constructor() {
    super();
  }

  shade(lights, renderModel, material) {
    var c, len1, light, o;
    c = new Color();
    for (o = 0, len1 = lights.length; o < len1; o++) {
      light = lights[o];
      switch (light.type) {
        case 'ambient':
          ShaderUtils.applyAmbient(c, light);
      }
    }
    c.multiplyChannels(material.color).clamp(0, 0xFF);
    return c;
  };


}

export class Flat extends Shader {
  constructor() {
    super();
  }

  shade(lights, renderModel, material) {
    return material.color;
  };

}

export let Shaders = {
  phong: function () {
    return new Phong();
  },
  diffuse: function () {
    return new DiffusePhong();
  },
  ambient: function () {
    return new Ambient();
  },
  flat: function () {
    return new Flat();
  }
};

export let Affine = {
  ORTHONORMAL_BASIS: function () {
    return [P(0, 0, 0), P(20, 0, 0), P(0, 20, 0)];
  },
  INITIAL_STATE_MATRIX: [[20, 0, 1, 0, 0, 0], [0, 20, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 0, 20, 0, 1], [0, 0, 0, 0, 20, 1], [0, 0, 0, 0, 0, 1]],
  solveForAffineTransform: function (points) {
    var A, b, i, j, n, o, ref, ref1, ref2, u, x;
    A = Affine.INITIAL_STATE_MATRIX;
    b = [points[1].x, points[2].x, points[0].x, points[1].y, points[2].y, points[0].y];
    x = new Array(6);
    n = A.length;
    for (i = o = ref = n - 1; o >= 0; i = o += -1) {
      x[i] = b[i];
      for (j = u = ref1 = i + 1, ref2 = n; ref1 <= ref2 ? u < ref2 : u > ref2; j = ref1 <= ref2 ? ++u : --u) {
        x[i] -= A[i][j] * x[j];
      }
      x[i] /= A[i][i];
    }
    return x;
  }
};

export class RenderContext {
  layers: any
  constructor() {

    this.layers = [];
  }

  render() {
    var layer, len1, o, ref;
    this.reset();
    ref = this.layers;
    for (o = 0, len1 = ref.length; o < len1; o++) {
      layer = ref[o];
      layer.context.reset();
      layer.layer.render(layer.context);
      layer.context.cleanup();
    }
    this.cleanup();
    return this;
  };

  animate() {
    return new RenderAnimator(this);
  };

  layer(layer) {
    this.layers.push({
      layer: layer,
      context: this
    });
    return this;
  };

  sceneLayer(scene) {
    this.layer(new SceneLayer(scene));
    return this;
  };

  reset() { };

  cleanup() { };



}

export class RenderLayerContext {

  constructor() { }

  path() { };

  rect() { };

  circle() { };

  text() { };

  reset() { };

  cleanup() { };



}

export function Context(elementId, scene) {
  var context, ref, tag;
  if (scene == null) {
    scene = null;
  }
  tag = (ref = Util.element(elementId)) != null ? ref.tagName.toUpperCase() : void 0;
  context = (function () {
    switch (tag) {
      case 'SVG':
      case 'G':
      // return new SvgRenderContext(elementId);
      case 'CANVAS':
      // return new CanvasRenderContext(elementId);
    }
  })();
  if ((context != null) && (scene != null)) {
    context.sceneLayer(scene);
  }
  return context;
};

export class Painter {

  constructor() { }

  paint(renderModel, context) { };



}

export class PathPainter extends Painter {
  projection: any
  inFrustrum: any
  _checkFrustrum: any
  surface: any
  _math: any
  points: any
  _initRenderData: any
  _update: any
  projected: any
  viewport: any
  transformed: any
  transform: any
  constructor() {
    super();
  }

  Pathpaint(renderModel, context) {
    var painter, ref, ref1;
    painter = context.path().path(renderModel.projected.points);
    if (renderModel.fill != null) {
      painter.fill({
        fill: renderModel.fill == null ? 'none' : renderModel.fill.hex(),
        'fill-opacity': ((ref = renderModel.fill) != null ? ref.a : void 0) == null ? 1.0 : renderModel.fill.a / 255.0
      });
    }
    if (renderModel.stroke != null) {
      return painter.draw({
        fill: 'none',
        stroke: renderModel.stroke == null ? 'none' : renderModel.stroke.hex(),
        'stroke-width': (ref1 = renderModel.surface['stroke-width']) != null ? ref1 : 1
      });
    }
  };



}

export class TextPainter extends Painter {

  projection: any
  inFrustrum: any
  _checkFrustrum: any
  surface: any
  _math: any
  points: any
  _initRenderData: any
  _update: any
  projected: any
  viewport: any
  transformed: any
  transform: any
  constructor() {
    super();
  }

  Textpaint(renderModel, context) {
    var ref, style, xform;
    style = {
      fill: renderModel.fill == null ? 'none' : renderModel.fill.hex(),
      font: renderModel.surface.font,
      'text-anchor': (ref = renderModel.surface.anchor) != null ? ref : 'middle'
    };
    xform = Affine.solveForAffineTransform(renderModel.projected.points);
    return context.text().fillText(xform, renderModel.surface.text, style);
  };



}

export let Painters = {
  path: new PathPainter(),
  text: new TextPainter()
};

let DEFAULT_NORMAL = Points.Z();

export class RenderModel {
  transform: any
  projection: any
  transformed: any
  surface: any
  projected: any
  points: any
  viewport: any
  inFrustrum: any
  constructor(surface1, transform1, projection1, viewport1) {
    this.surface = surface1;
    this.transform = transform1;
    this.projection = projection1;
    this.viewport = viewport1;
    this.points = this.surface.points;
    this.transformed = this._initRenderData();
    this.projected = this._initRenderData();
    this._update();
  }

  update(transform, projection, viewport) {
    if (!this.surface.dirty && Util.arraysEqual(transform.m, this.transform.m) && Util.arraysEqual(projection.m, this.projection.m) && Util.arraysEqual(viewport.m, this.viewport.m)) {

    } else {
      this.transform = transform;
      this.projection = projection;
      this.viewport = viewport;
      return this._update();
    }
  };

  _update() {
    var cameraSpace;
    this._math(this.transformed, this.points, this.transform, false);
    cameraSpace = this.transformed.points.map((function (_this) {
      return function (p) {
        return p.copy().transform(_this.projection);
      };
    })(this));
    this.inFrustrum = this._checkFrustrum(cameraSpace);
    this._math(this.projected, cameraSpace, this.viewport, true);
    return this.surface.dirty = false;
  };

  _checkFrustrum(points) {
    var len1, o, p;
    for (o = 0, len1 = points.length; o < len1; o++) {
      p = points[o];
      if (p.z <= -2) {
        return false;
      }
    }
    return true;
  };

  _initRenderData() {
    var p;
    return {
      points: (function () {
        var len1, o, ref, results;
        ref = this.points;
        results = [];
        for (o = 0, len1 = ref.length; o < len1; o++) {
          p = ref[o];
          results.push(p.copy());
        }
        return results;
      }).call(this),
      bounds: new Bounds(),
      barycenter: P(),
      normal: P(),
      v0: P(),
      v1: P()
    };
  };

  _math(set, points, transform, applyClip) {
    var i, l1, len1, len2, len3, o, p, ref, ref1, sp, u;
    if (applyClip == null) {
      applyClip = false;
    }
    for (i = o = 0, len1 = points.length; o < len1; i = ++o) {
      p = points[i];
      sp = set.points[i];
      sp.set(p).transform(transform);
      if (applyClip) {
        sp.divide(sp.w);
      }
    }
    set.barycenter.multiply(0);
    ref = set.points;
    for (u = 0, len2 = ref.length; u < len2; u++) {
      p = ref[u];
      set.barycenter.add(p);
    }
    set.barycenter.divide(set.points.length);
    set.bounds.reset();
    ref1 = set.points;
    for (l1 = 0, len3 = ref1.length; l1 < len3; l1++) {
      p = ref1[l1];
      set.bounds.add(p);
    }
    if (set.points.length < 2) {
      set.v0.set(DEFAULT_NORMAL);
      set.v1.set(DEFAULT_NORMAL);
      return set.normal.set(DEFAULT_NORMAL);
    } else {
      set.v0.set(set.points[1]).subtract(set.points[0]);
      set.v1.set(set.points[points.length - 1]).subtract(set.points[0]);
      return set.normal.set(set.v0).cross(set.v1).normalize();
    }
  };



}

export class LightRenderModel {
  normal: any;
  point: any;
  light: any;
  intensity: any
  type: any
  color: any
  colorIntensity: any
  id: any
  constructor(light1, transform) {
    var origin;
    this.light = light1;
    this.colorIntensity = this.light.color.copy().scale(this.light.intensity);
    this.type = this.light.type;
    this.intensity = this.light.intensity;
    this.point = this.light.point.copy().transform(transform);
    origin = Points.ZERO().transform(transform);
    this.normal = this.light.normal.copy().transform(transform).subtract(origin).normalize();
  }



}

export class RenderLayer {

  constructor() {

  }

  render(context) { };



}

export class SceneLayer extends RenderLayer {
  scene: any
  width: any
  _paint: any
  fill: any
  height: any
  elementFactory: any
  _svgTag: any
  _attributes: any
  constructor(scene1) {
    super();
    this.scene = scene1;
  }

  render(context) {
    var len1, o, ref, renderModel, results;
    ref = this.scene.render();
    results = [];
    for (o = 0, len1 = ref.length; o < len1; o++) {
      renderModel = ref[o];
      results.push(renderModel.surface.painter.paint(renderModel, context));
    }
    return results;
  };

}

export class FillLayer extends RenderLayer {

  _paint: any
  width: any
  fill: any
  height: any
  elementFactory: any
  _svgTag: any
  _attributes: any
  constructor(width1, height1, fill1) {
    super();
    this.width = width1 != null ? width1 : 500;
    this.height = height1 != null ? height1 : 500;
    this.fill = fill1 != null ? fill1 : '#EEE';

  }

  render(context) {
    return context.rect().rect(this.width, this.height).fill({
      fill: this.fill
    });
  };



}
/*
function _svg (name) {
  return document.createElementNS('http://www.w3.org/2000/svg', name);
};

export class SvgStyler {
  _attributes = {};

  _svgTag = 'g';
  elementFactory: any
  constructor(elementFactory) {
    this.elementFactory = elementFactory;
  }

  clear() {
    this._attributes = {};
    return this;
  };

  fill(style) {
    if (style == null) {
      style = {};
    }
    this._paint(style);
    return this;
  };

  draw(style) {
    if (style == null) {
      style = {};
    }
    this._paint(style);
    return this;
  };

  _paint(style) {
    var el, key, ref, str, value;
    el = this.elementFactory(this._svgTag);
    str = '';
    for (key in style) {
      value = style[key];
      str += key + ":" + value + ";";
    }
    el.setAttribute('style', str);
    ref = this._attributes;
    for (key in ref) {
      value = ref[key];
      el.setAttribute(key, value);
    }
    return el;
  };



}

export class SvgPathPainter extends SvgStyler{
 
  constructor(elementFactory) {
    super(elementFactory);
    this._svgTag = 'path';
  }
 

  SvgPathpath(points) {
    this._attributes.d = 'M' + points.map(function (p) {
      return p.x + " " + p.y;
    }).join('L');
    return this;
  };



}

export class SvgTextPainter {
  _svgTag = 'text';
  elementFactory: any
  constructor(elementFactory) {
    this.elementFactory = elementFactory;
  }

  SvgTextfillText(m, text, style) {
    var el, key, str, value;
    if (style == null) {
      style = {};
    }
    el = this.elementFactory(this._svgTag);
    el.setAttribute('transform', "matrix(" + m[0] + " " + m[3] + " " + (-m[1]) + " " + (-m[4]) + " " + m[2] + " " + m[5] + ")");
    str = '';
    for (key in style) {
      value = style[key];
      if (value != null) {
        str += key + ":" + value + ";";
      }
    }
    el.setAttribute('style', str);
    return el.textContent = text;
  };
}

export class SvgRectPainter extends SvgStyler{

  svg: any
  _attributes: any
  rectPainter: any
  _i: any
  ctx: any
  circlePainter: any
  group: any
  _elementFactory: any
  layers: any
  textPainter: any
  pathPainter: any
  constructor(_elementFactory) {
    super(_elementFactory);
    this._svgTag = 'rect';
  }

 

  SvgRectrect(width, height) {
    this._attributes.width = width;
    this._attributes.height = height;
    return this;
  };



}

export class SvgCirclePainter extends SvgStyler{

  svg: any
  _attributes: any
  rectPainter: any
  _i: any
  ctx: any
  circlePainter: any
  group: any
  _elementFactory: any
  layers: any
  textPainter: any
  pathPainter: any
  constructor(_elementFactory) {
    super(_elementFactory);
  }

  _svgTag = 'circle';

  SvgCirclecircle(center, radius) {
    this._attributes.cx = center.x;
    this._attributes.cy = center.y;
    this._attributes.r = radius;
    return this;
  };



}

export class SvgLayerRenderContext extends SvgStyler{

  svg: any
  rectPainter: any
  _i: any
  ctx: any
  circlePainter: any
  group: any
  _elementFactory: any
  layers: any
  textPainter: any
  pathPainter: any
  constructor(group1,elementFactory) {
    super(elementFactory);
    this.group = group1;

    this.pathPainter = new SvgPathPainter(this._elementFactory);
    this.textPainter = new SvgTextPainter(this._elementFactory);
    this.circlePainter = new SvgCirclePainter(this._elementFactory);
    this.rectPainter = new SvgRectPainter(this._elementFactory);
    this._i = 0;
  }

  SvgLayerpath() {
    return this.pathPainter.clear();
  };

  SvgLayerrect() {
    return this.rectPainter.clear();
  };

  SvgLayercircle() {
    return this.circlePainter.clear();
  };

  SvgLayertext() {
    return this.textPainter;
  };

  SvgLayerreset() {
    return this._i = 0;
  };

  SvgLayercleanup() {
    var children, results;
    children = this.group.childNodes;
    results = [];
    while (this._i < children.length) {
      children[this._i].setAttribute('style', 'display: none;');
      results.push(this._i++);
    }
    return results;
  };

  SvgLayer_elementFactory(type) {
    var children, current, path;
    children = this.group.childNodes;
    if (this._i >= children.length) {
      path = _svg(type);
      this.group.appendChild(path);
      this._i++;
      return path;
    }
    current = children[this._i];
    if (current.tagName === type) {
      this._i++;
      return current;
    } else {
      path = _svg(type);
      this.group.replaceChild(path, current);
      this._i++;
      return path;
    }
  };



}

export class SvgRenderContext {
  extend(SvgRenderContext, superClass);

  ctx: any
  layers: any
  svg: any
  constructor(svg) {
    this.svg = svg;
    SvgRenderContext.__super__.constructor.call(this);
    this.svg = Util.element(this.svg);
  }

  Svglayer(layer) {
    var group;
    this.svg.appendChild(group = _svg('g'));
    this.layers.push({
      layer: layer,
      context: new SvgLayerRenderContext(group)
    });
    return this;
  };



})(RenderContext);

SvgContext = function (elementId, scene) {
  var context;
  context = new SvgRenderContext(elementId);
  if (scene != null) {
    context.sceneLayer(scene);
  }
  return context;
};

export class CanvasStyler {
  ctx: any
  constructor(ctx) {
    this.ctx = ctx;
  }

  draw(style) {
    if (style == null) {
      style = {};
    }
    if (style.stroke != null) {
      this.ctx.strokeStyle = style.stroke;
    }
    if (style['stroke-width'] != null) {
      this.ctx.lineWidth = style['stroke-width'];
    }
    if (style['text-anchor'] != null) {
      this.ctx.textAlign = style['text-anchor'];
    }
    this.ctx.stroke();
    return this;
  };

  fill(style) {
    if (style == null) {
      style = {};
    }
    if (style.fill != null) {
      this.ctx.fillStyle = style.fill;
    }
    if (style['text-anchor'] != null) {
      this.ctx.textAlign = style['text-anchor'];
    }
    if (style['fill-opacity']) {
      this.ctx.globalAlpha = style['fill-opacity'];
    }
    this.ctx.fill();
    return this;
  };



}

export class CanvasPathPainter {
  extend(CanvasPathPainter, superClass);

  _cssToCanvasAnchor: any
  ctx: any
  constructor() {
    return CanvasPathPainter.__super__.constructor.apply(this, args);
  }

  CanvasPathpath(points) {
    var i, len1, o, p;
    this.ctx.beginPath();
    for (i = o = 0, len1 = points.length; o < len1; i = ++o) {
      p = points[i];
      if (i === 0) {
        this.ctx.moveTo(p.x, p.y);
      } else {
        this.ctx.lineTo(p.x, p.y);
      }
    }
    this.ctx.closePath();
    return this;
  };



})(CanvasStyler);

export class CanvasRectPainter {
  extend(CanvasRectPainter, superClass);

  _cssToCanvasAnchor: any
  ctx: any
  constructor() {
    return CanvasRectPainter.__super__.constructor.apply(this, args);
  }

  CanvasRectrect(width, height) {
    this.ctx.rect(0, 0, width, height);
    return this;
  };



})(CanvasStyler);

export class CanvasCirclePainter {
  extend(CanvasCirclePainter, superClass);

  _cssToCanvasAnchor: any
  ctx: any
  constructor() {
    return CanvasCirclePainter.__super__.constructor.apply(this, args);
  }

  CanvasCirclecircle(center, radius) {
    this.ctx.beginPath();
    this.ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI, true);
    return this;
  };



})(CanvasStyler);

export class CanvasTextPainter {
  _cssToCanvasAnchor: any
  ctx: any
  constructor(ctx) {
    this.ctx = ctx;
  }

  CanvasTextfillText(m, text, style) {
    if (style == null) {
      style = {};
    }
    this.ctx.save();
    this.ctx.setTransform(m[0], m[3], -m[1], -m[4], m[2], m[5]);
    if (style.font != null) {
      this.ctx.font = style.font;
    }
    if (style.fill != null) {
      this.ctx.fillStyle = style.fill;
    }
    if (style['text-anchor'] != null) {
      this.ctx.textAlign = this._cssToCanvasAnchor(style['text-anchor']);
    }
    this.ctx.fillText(text, 0, 0);
    this.ctx.restore();
    return this;
  };

  CanvasText_cssToCanvasAnchor(anchor) {
    if (anchor === 'middle') {
      return 'center';
    }
    return anchor;
  };



}

export class CanvasLayerRenderContext {
  extend(CanvasLayerRenderContext, superClass);

  ctx: any
  ciclePainter: any
  layers: any
  rectPainter: any
  textPainter: any
  el: any
  pathPainter: any
  constructor(ctx) {
    this.ctx = ctx;
    this.pathPainter = new CanvasPathPainter(this.ctx);
    this.ciclePainter = new CanvasCirclePainter(this.ctx);
    this.textPainter = new CanvasTextPainter(this.ctx);
    this.rectPainter = new CanvasRectPainter(this.ctx);
  }

  CanvasLayerpath() {
    return this.pathPainter;
  };

  CanvasLayerrect() {
    return this.rectPainter;
  };

  CanvasLayercircle() {
    return this.ciclePainter;
  };

  CanvasLayertext() {
    return this.textPainter;
  };



})(RenderLayerContext);

export class CanvasRenderContext {
  extend(CanvasRenderContext, superClass);

  layers: any
  el: any
  ctx: any
  constructor(el1) {
    this.el = el1;
    CanvasRenderContext.__super__.constructor.call(this);
    this.el = Util.element(this.el);
    this.ctx = this.el.getContext('2d');
  }

  Canvaslayer(layer) {
    this.layers.push({
      layer: layer,
      context: new CanvasLayerRenderContext(this.ctx)
    });
    return this;
  };

  Canvasreset() {
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    return this.ctx.clearRect(0, 0, this.el.width, this.el.height);
  };



})(RenderContext);

CanvasContext = function (elementId, scene) {
  var context;
  context = new CanvasRenderContext(elementId);
  if (scene != null) {
    context.sceneLayer(scene);
  }
  return context;
};
*/
export class WindowEvents {
  dispatch = Events.dispatch('mouseMove', 'mouseDown', 'mouseUp', 'touchStart', 'touchMove', 'touchEnd', 'touchCancel');
  // if (typeof window !== "undefined" && window !== null) {
  //   window.addEventListener('mouseup', dispatch.mouseUp, true);
  //   window.addEventListener('mousedown', dispatch.mouseDown, true);
  //   window.addEventListener('mousemove', dispatch.mouseMove, true);
  //   window.addEventListener('touchstart', dispatch.touchStart, true);
  //   window.addEventListener('touchmove', dispatch.touchMove, true);
  //   window.addEventListener('touchend', dispatch.touchEnd, true);
  //   window.addEventListener('touchcancel', dispatch.touchCancel, true);
  // }
  // return {
  //   on: dispatch.on
  // };
  static on(type, listener) { return this }
}

export class MouseEvents {
  _mouseDown: any
  on: any
  defaults: any
  el: any
  _uid: any
  dispatch: any
  constructor(el1, options = {}) {
    this.el = el1;




    Util.defaults(this, options, this.defaults);
    this.el = Util.element(this.el);
    this._uid = Util.uniqueId('mouser-');
    this.dispatch = Events.dispatch('dragStart', 'drag', 'dragEnd', 'mouseMove', 'mouseDown', 'mouseUp', 'mouseWheel');
    this.on = this.dispatch.on;
    this._mouseDown = false;
    this.attach();
  }

  attach() {
    this.el.addEventListener('touchstart', this._onMouseDown);
    this.el.addEventListener('mousedown', this._onMouseDown);
    return this.el.addEventListener('mousewheel', this._onMouseWheel);
  };

  detach() {
    this.el.removeEventListener('touchstart', this._onMouseDown);
    this.el.removeEventListener('mousedown', this._onMouseDown);
    return this.el.removeEventListener('mousewheel', this._onMouseWheel);
  };

  _onMouseMove(e) {
    this.dispatch.mouseMove(e);
    e.preventDefault();
    e.stopPropagation();
    if (this._mouseDown) {
      return this.dispatch.drag(e);
    }
  };

  _onMouseDown(e) {
    this._mouseDown = true;
    WindowEvents.on("mouseUp." + this._uid, this._onMouseUp);
    WindowEvents.on("mouseMove." + this._uid, this._onMouseMove);
    WindowEvents.on("touchEnd." + this._uid, this._onMouseUp);
    WindowEvents.on("touchCancel." + this._uid, this._onMouseUp);
    WindowEvents.on("touchMove." + this._uid, this._onMouseMove);
    this.dispatch.mouseDown(e);
    return this.dispatch.dragStart(e);
  };

  _onMouseUp(e) {
    this._mouseDown = false;
    WindowEvents.on("mouseUp." + this._uid, null);
    WindowEvents.on("mouseMove." + this._uid, null);
    WindowEvents.on("touchEnd." + this._uid, null);
    WindowEvents.on("touchCancel." + this._uid, null);
    WindowEvents.on("touchMove." + this._uid, null);
    this.dispatch.mouseUp(e);
    return this.dispatch.dragEnd(e);
  };

  _onMouseWheel(e) {
    return this.dispatch.mouseWheel(e);
  };



}

export class InertialMouse {
  static inertiaExtinction = 0.1;

  static smoothingTimeout = 300;

  static inertiaMsecDelay = 30;

  x: any
  xy: any
  y: any
  lastUpdate: any
  constructor() {
    this.reset();
  }

  get() {
    var scale;
    scale = 1000 / InertialMouse.inertiaMsecDelay;
    return [this.x * scale, this.y * scale];
  };

  reset() {
    this.xy = [0, 0];
    return this;
  };

  update(xy) {
    var msec, t;
    if (this.lastUpdate != null) {
      msec = new Date().getTime() - this.lastUpdate.getTime();
      xy = xy.map(function (x) {
        return x / Math.max(msec, 1);
      });
      t = Math.min(1, msec / InertialMouse.smoothingTimeout);
      this.x = t * xy[0] + (1.0 - t) * this.x;
      this.y = t * xy[1] + (1.0 - t) * this.y;
    } else {
      this.x = xy[0], this.y = xy[1];
    }
    this.lastUpdate = new Date();
    return this;
  };

  damp() {
    this.x *= 1.0 - InertialMouse.inertiaExtinction;
    this.y *= 1.0 - InertialMouse.inertiaExtinction;
    return this;
  };



}

export class Drag {
  defaults = {
    inertia: false
  };

  _dragState: any
  on: any
  _inertiaRunning: any
  el: any
  inertia: any
  _uid: any
  dispatch: any
  constructor(el1, options) {
    var mouser;
    this.el = el1;







    Util.defaults(this, options, this.defaults);
    this.el = Util.element(this.el);
    this._uid = Util.uniqueId('dragger-');
    this._inertiaRunning = false;
    this._dragState = {
      dragging: false,
      origin: null,
      last: null,
      inertia: new InertialMouse()
    };
    this.dispatch = Events.dispatch('drag', 'dragStart', 'dragEnd', 'dragEndInertia');
    this.on = this.dispatch.on;
    mouser = new MouseEvents(this.el);
    mouser.on("dragStart." + this._uid, this._onDragStart);
    mouser.on("dragEnd." + this._uid, this._onDragEnd);
    mouser.on("drag." + this._uid, this._onDrag);
  }

  _getPageCoords(e) {
    var ref, ref1;
    if (((ref = e.touches) != null ? ref.length : void 0) > 0) {
      return [e.touches[0].pageX, e.touches[0].pageY];
    } else if (((ref1 = e.changedTouches) != null ? ref1.length : void 0) > 0) {
      return [e.changedTouches[0].pageX, e.changedTouches[0].pageY];
    } else {
      return [e.pageX, e.pageY];
    }
  };

  _onDragStart(e) {
    this._stopInertia();
    this._dragState.dragging = true;
    this._dragState.origin = this._getPageCoords(e);
    this._dragState.last = this._getPageCoords(e);
    return this.dispatch.dragStart(e);
  };

  _onDragEnd(e) {
    var dragEvent, page;
    this._dragState.dragging = false;
    if (this.inertia) {
      page = this._getPageCoords(e);
      dragEvent = {
        offset: [page[0] - this._dragState.origin[0], page[1] - this._dragState.origin[1]],
        offsetRelative: [page[0] - this._dragState.last[0], page[1] - this._dragState.last[1]]
      };
      this._dragState.inertia.update(dragEvent.offsetRelative);
      this._startInertia();
    }
    return this.dispatch.dragEnd(e);
  };

  _onDrag(e) {
    var dragEvent, page;
    page = this._getPageCoords(e);
    dragEvent = {
      offset: [page[0] - this._dragState.origin[0], page[1] - this._dragState.origin[1]],
      offsetRelative: [page[0] - this._dragState.last[0], page[1] - this._dragState.last[1]]
    };
    this.dispatch.drag(dragEvent);
    if (this.inertia) {
      this._dragState.inertia.update(dragEvent.offsetRelative);
    }
    return this._dragState.last = page;
  };

  _onInertia() {
    var intertia;
    if (!this._inertiaRunning) {
      return;
    }
    intertia = this._dragState.inertia.damp().get();
    if (Math.abs(intertia[0]) < 1 && Math.abs(intertia[1]) < 1) {
      this._stopInertia();
      this.dispatch.dragEndInertia();
      return;
    }
    this.dispatch.drag({
      offset: [this._dragState.last[0] - this._dragState.origin[0], this._dragState.last[0] - this._dragState.origin[1]],
      offsetRelative: intertia
    });
    this._dragState.last = [this._dragState.last[0] + intertia[0], this._dragState.last[1] + intertia[1]];
    return this._startInertia();
  };

  _startInertia() {
    this._inertiaRunning = true;
    return setTimeout(this._onInertia, InertialMouse.inertiaMsecDelay);
  };

  _stopInertia() {
    this._dragState.inertia.reset();
    return this._inertiaRunning = false;
  };



}

export class Zoom {
  defaults = {
    speed: 0.25
  };

  on: any
  speed: any
  el: any
  _uid: any
  dispatch: any
  constructor(el1, options) {
    var mouser;
    this.el = el1;

    Util.defaults(this, options, this.defaults);
    this.el = Util.element(this.el);
    this._uid = Util.uniqueId('zoomer-');
    this.dispatch = Events.dispatch('zoom');
    this.on = this.dispatch.on;
    mouser = new MouseEvents(this.el);
    mouser.on("mouseWheel." + this._uid, this._onMouseWheel);
  }

  _onMouseWheel(e) {
    var sign, zoom, zoomFactor;
    e.preventDefault();
    sign = e.wheelDelta / Math.abs(e.wheelDelta);
    zoomFactor = Math.abs(e.wheelDelta) / 120 * this.speed;
    zoom = Math.pow(2, sign * zoomFactor);
    return this.dispatch.zoom({
      zoom: zoom
    });
  };



}

export class Surface {
  cullBackfaces = true;

  fillMaterial = new Material();

  strokeMaterial = null;

  points: any
  painter: any
  id: any
  constructor(points1, painter1 = null) {
    this.points = points1;
    this.painter = painter1 != null ? painter1 : Painters.path;
    this.id = 's' + Util.uniqueId();
  }

  fill(fill) {
    this.fillMaterial = Material.create(fill);
    return this;
  };

  stroke(stroke) {
    this.strokeMaterial = Material.create(stroke);
    return this;
  };



}

export class Shape extends Transformable {
  _lastTime: any
  _lastTimestamp: any
  animateFrame: any
  _delayCompensation: any
  add: any
  surfaces: any
  timestamp: any
  frame: any
  children: any
  m: any
  frameDelay: any
  on: any
  type: any
  _msecDelay: any
  _eachRenderable: any
  _timestamp: any
  dispatch: any
  lights: any
  _running: any
  constructor(type1, surfaces1) {
    super();
    this.type = type1;
    this.surfaces = surfaces1;
  }

  eachSurface(f) {
    this.surfaces.forEach(f);
    return this;
  };

  fill(fill) {
    this.eachSurface(function (s) {
      return s.fill(fill);
    });
    return this;
  };

  stroke(stroke) {
    this.eachSurface(function (s) {
      return s.stroke(stroke);
    });
    return this;
  };



}

export class Model extends Transformable {

  _lastTimestamp: any
  animateFrame: any
  _delayCompensation: any
  timestamp: any
  frame: any
  children: any
  m: any
  frameDelay: any
  on: any
  _msecDelay: any
  _lastTime: any
  _timestamp: any
  dispatch: any
  lights: any
  _running: any
  constructor() {
    super();
    this.children = [];
    this.lights = [];
  }

  add(...args) {
    var child, childs, len1, o;
    childs = 1 <= args.length ? slice.call(args, 0) : [];
    for (o = 0, len1 = childs.length; o < len1; o++) {
      child = childs[o];
      if (child instanceof Shape || child instanceof Model) {
        this.children.push(child);
      } else if (child instanceof Light) {
        this.lights.push(child);
      }
    }
    return this;
  };

  remove(...args) {
    var child, childs, i, len1, o, results;
    childs = 1 <= args.length ? slice.call(args, 0) : [];
    results = [];
    for (o = 0, len1 = childs.length; o < len1; o++) {
      child = childs[o];
      while ((i = this.children.indexOf(child)) >= 0) {
        this.children.splice(i, 1);
      }
      results.push((function () {
        var results1;
        results1 = [];
        while ((i = this.lights.indexOf(child)) >= 0) {
          results1.push(this.lights.splice(i, 1));
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  append() {
    var model;
    model = new Model;
    this.add(model);
    return model;
  };

  eachShape(f) {
    var child, len1, o, ref, results;
    ref = this.children;
    results = [];
    for (o = 0, len1 = ref.length; o < len1; o++) {
      child = ref[o];
      if (child instanceof Shape) {
        f.call(this, child);
      }
      if (child instanceof Model) {
        results.push(child.eachShape(f));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  eachRenderable(lightFn, shapeFn) {
    return this._eachRenderable(lightFn, shapeFn, [], this.m);
  };

  _eachRenderable(lightFn, shapeFn, lightModels, transform) {
    var child, len1, len2, light, o, ref, ref1, results, u;
    if (this.lights.length > 0) {
      lightModels = lightModels.slice();
    }
    ref = this.lights;
    for (o = 0, len1 = ref.length; o < len1; o++) {
      light = ref[o];
      if (!light.enabled) {
        continue;
      }
      lightModels.push(lightFn.call(this, light, light.m.copy().multiply(transform)));
    }
    ref1 = this.children;
    results = [];
    for (u = 0, len2 = ref1.length; u < len2; u++) {
      child = ref1[u];
      if (child instanceof Shape) {
        shapeFn.call(this, child, lightModels, child.m.copy().multiply(transform));
      }
      if (child instanceof Model) {
        results.push(child._eachRenderable(lightFn, shapeFn, lightModels, child.m.copy().multiply(transform)));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };



}

export let Models = {
  "default": function () {
    var model;
    model = new Model();
    model.add(Lights.directional({
      normal: P(-1, 1, 1).normalize(),
      color: Colors.hsl(0.1, 0.3, 0.7),
      intensity: 0.004
    }));
    model.add(Lights.directional({
      normal: P(1, 1, -1).normalize(),
      intensity: 0.003
    }));
    model.add(Lights.ambient({
      intensity: 0.0015
    }));
    return model;
  }
};


let DEFAULT_FRAME_DELAY = 30;

export class Animator {
  _lastTime: any
  _msecDelay: any
  _running: any
  on: any
  frameDelay: any
  _timestamp: any
  timestamp: any
  _lastTimestamp: any
  dispatch: any
  _delayCompensation: any
  constructor() {

    this.dispatch = Events.dispatch('beforeFrame', 'afterFrame', 'frame');
    this.on = this.dispatch.on;
    this.timestamp = 0;
    this._running = false;
    this.frameDelay = null;
  }

  start() {
    this._running = true;
    if (this.frameDelay != null) {
      this._lastTime = new Date().valueOf();
      this._delayCompensation = 0;
    }
    this.animateFrame();
    return this;
  };

  stop() {
    this._running = false;
    return this;
  };

  animateFrame() {
    var delta, frameDelay, ref3;
    if ((requestAnimationFrame != null) && (this.frameDelay == null)) {
      requestAnimationFrame(this.frame);
    } else {
      delta = new Date().valueOf() - this._lastTime;
      this._lastTime += delta;
      this._delayCompensation += delta;
      frameDelay = (ref3 = this.frameDelay) != null ? ref3 : DEFAULT_FRAME_DELAY;
      setTimeout(this.frame, frameDelay - this._delayCompensation);
    }
    return this;
  };

  frame(t) {
    var deltaTimestamp, ref3;
    if (!this._running) {
      return;
    }
    this._timestamp = t != null ? t : this._timestamp + ((ref3 = this._msecDelay) != null ? ref3 : DEFAULT_FRAME_DELAY);
    deltaTimestamp = this._lastTimestamp != null ? this._timestamp - this._lastTimestamp : this._timestamp;
    this.dispatch.beforeFrame(this._timestamp, deltaTimestamp);
    this.dispatch.frame(this._timestamp, deltaTimestamp);
    this.dispatch.afterFrame(this._timestamp, deltaTimestamp);
    this._lastTimestamp = this._timestamp;
    this.animateFrame();
    return this;
  };

  onBefore(handler) {
    this.on("beforeFrame." + (Util.uniqueId('animator-')), handler);
    return this;
  };

  onAfter(handler) {
    this.on("afterFrame." + (Util.uniqueId('animator-')), handler);
    return this;
  };

  onFrame(handler) {
    this.on("frame." + (Util.uniqueId('animator-')), handler);
    return this;
  };



}

export class RenderAnimator extends Animator {

  t: any
  duration: any
  tFrac: any
  firstFrame: any
  defaults: any
  lastFrame: any
  startT: any
  constructor(context) {
    super();
    this.onFrame(context.render);
  }



}

export class Transition {
  defaults = {
    duration: 100
  };

  duration: any
  tFrac: any
  t: any
  startT: any
  constructor(options) {
    if (options == null) {
      options = {};
    }
    Util.defaults(this, options, this.defaults);
  }

  update(t) {
    if (this.t == null) {
      this.firstFrame();
      this.startT = t;
    }
    this.t = t;
    this.tFrac = (this.t - this.startT) / this.duration;
    this.frame();
    if (this.tFrac >= 1.0) {
      this.lastFrame();
      return false;
    }
    return true;
  };

  firstFrame() { };

  frame() { };

  lastFrame() { };



}

export class TransitionAnimator extends Animator {
  update(arg0: any): any {

  }
  transitions: any[];
  queue: any[];

  duration: any
  tFrac: any
  t: any
  startT: any
  constructor() {
    super();
    this.queue = [];
    this.transitions = [];
    this.onFrame(this.update);
  }

  Transitionadd(txn) {
    return this.transitions.push(txn);
  };

  Transitionkeyframe() {
    this.queue.push(this.transitions);
    return this.transitions = [];
  };

  Transitionupdate(t) {
    var transitions;
    if (!this.queue.length) {
      return;
    }
    transitions = this.queue.shift();
    transitions = transitions.filter(function (transition) {
      return transition.update(t);
    });
    if (transitions.length) {
      return this.queue.unshift(transitions);
    }
  };



}

let TETRAHEDRON_COORDINATE_MAP = [[0, 2, 1], [0, 1, 3], [3, 2, 0], [1, 2, 3]];

let CUBE_COORDINATE_MAP = [[0, 1, 3, 2], [5, 4, 6, 7], [1, 0, 4, 5], [2, 3, 7, 6], [3, 1, 5, 7], [0, 2, 6, 4]];

let PYRAMID_COORDINATE_MAP = [[1, 0, 2, 3], [0, 1, 4], [2, 0, 4], [3, 2, 4], [1, 3, 4]];

let EQUILATERAL_TRIANGLE_ALTITUDE = Math.sqrt(3.0) / 2.0;

let ICOS_X = 0.525731112119133606;

let ICOS_Z = 0.850650808352039932;

let ICOSAHEDRON_POINTS = [P(-ICOS_X, 0.0, -ICOS_Z), P(ICOS_X, 0.0, -ICOS_Z), P(-ICOS_X, 0.0, ICOS_Z), P(ICOS_X, 0.0, ICOS_Z), P(0.0, ICOS_Z, -ICOS_X), P(0.0, ICOS_Z, ICOS_X), P(0.0, -ICOS_Z, -ICOS_X), P(0.0, -ICOS_Z, ICOS_X), P(ICOS_Z, ICOS_X, 0.0), P(-ICOS_Z, ICOS_X, 0.0), P(ICOS_Z, -ICOS_X, 0.0), P(-ICOS_Z, -ICOS_X, 0.0)];

let ICOSAHEDRON_COORDINATE_MAP = [[0, 4, 1], [0, 9, 4], [9, 5, 4], [4, 5, 8], [4, 8, 1], [8, 10, 1], [8, 3, 10], [5, 3, 8], [5, 2, 3], [2, 7, 3], [7, 10, 3], [7, 6, 10], [7, 11, 6], [11, 0, 6], [0, 1, 6], [6, 1, 10], [9, 0, 11], [9, 11, 2], [9, 2, 5], [7, 2, 11]];

export let Shapes = {
  obj: function (objContents, cullBackfaces) {
    var parser;
    if (cullBackfaces == null) {
      cullBackfaces = true;
    }
    parser = new ObjParser();
    parser.parse(objContents);
    return new Shape('obj', parser.mapFacePoints(function (points) {
      var surface;
      surface = new Surface(points);
      surface.cullBackfaces = cullBackfaces;
      return surface;
    }));
  },
  cube: (function (_this) {
    return function () {
      var points;
      points = [P(-1, -1, -1), P(-1, -1, 1), P(-1, 1, -1), P(-1, 1, 1), P(1, -1, -1), P(1, -1, 1), P(1, 1, -1), P(1, 1, 1)];
      return new Shape('cube', Shapes.mapPointsToSurfaces(points, CUBE_COORDINATE_MAP));
    };
  })(this),
  unitcube: (function (_this) {
    return function () {
      var points;
      points = [P(0, 0, 0), P(0, 0, 1), P(0, 1, 0), P(0, 1, 1), P(1, 0, 0), P(1, 0, 1), P(1, 1, 0), P(1, 1, 1)];
      return new Shape('unitcube', Shapes.mapPointsToSurfaces(points, CUBE_COORDINATE_MAP));
    };
  })(this),
  rectangle: (function (_this) {
    return function (point1, point2) {
      var compose, points;
      compose = function (x, y, z) {
        return P(x(point1.x, point2.x), y(point1.y, point2.y), z(point1.z, point2.z));
      };
      points = [compose(Math.min, Math.min, Math.min), compose(Math.min, Math.min, Math.max), compose(Math.min, Math.max, Math.min), compose(Math.min, Math.max, Math.max), compose(Math.max, Math.min, Math.min), compose(Math.max, Math.min, Math.max), compose(Math.max, Math.max, Math.min), compose(Math.max, Math.max, Math.max)];
      return new Shape('rect', Shapes.mapPointsToSurfaces(points, CUBE_COORDINATE_MAP));
    };
  })(this),
  pyramid: (function (_this) {
    return function () {
      var points;
      points = [P(0, 0, 0), P(0, 0, 1), P(1, 0, 0), P(1, 0, 1), P(0.5, 1, 0.5)];
      return new Shape('pyramid', Shapes.mapPointsToSurfaces(points, PYRAMID_COORDINATE_MAP));
    };
  })(this),
  tetrahedron: (function (_this) {
    return function () {
      var points;
      points = [P(1, 1, 1), P(-1, -1, 1), P(-1, 1, -1), P(1, -1, -1)];
      return new Shape('tetrahedron', Shapes.mapPointsToSurfaces(points, TETRAHEDRON_COORDINATE_MAP));
    };
  })(this),
  icosahedron: function () {
    return new Shape('icosahedron', Shapes.mapPointsToSurfaces(ICOSAHEDRON_POINTS, ICOSAHEDRON_COORDINATE_MAP));
  },
  sphere: function (subdivisions) {
    var i, o, ref3, triangles;
    if (subdivisions == null) {
      subdivisions = 2;
    }
    triangles = ICOSAHEDRON_COORDINATE_MAP.map(function (coords) {
      return coords.map(function (c) {
        return ICOSAHEDRON_POINTS[c];
      });
    });
    for (i = o = 0, ref3 = subdivisions; 0 <= ref3 ? o < ref3 : o > ref3; i = 0 <= ref3 ? ++o : --o) {
      triangles = Shapes._subdivideTriangles(triangles);
    }
    return new Shape('sphere', triangles.map(function (triangle) {
      return new Surface(triangle.map(function (v) {
        return v.copy();
      }));
    }));
  },
  pipe: function (point1, point2, radius = 1, segments = 8) {
    var axis, o, perp, points, quat, results, theta;
    if (radius == null) {
      radius = 1;
    }
    if (segments == null) {
      segments = 8;
    }
    axis = point2.copy().subtract(point1);
    perp = axis.perpendicular().multiply(radius);
    theta = -Math.PI * 2.0 / segments;
    quat = Quaternion.pointAngle(axis.copy().normalize(), theta).toMatrix();
    points = (function () {
      results = [];
      for (var o = 0; 0 <= segments ? o < segments : o > segments; 0 <= segments ? o++ : o--) { results.push(o); }
      return results;
    }).apply(this).map(function (i) {
      var p;
      p = point1.copy().add(perp);
      perp.transform(quat);
      return p;
    });
    return Shapes.extrude(points, axis);
  },
  patch: function (nx, ny) {
    var column, l1, len1, len2, len3, m1, o, o1, p, pts, pts0, pts1, ref3, ref4, ref5, ref6, surfaces, u, x, y;
    if (nx == null) {
      nx = 20;
    }
    if (ny == null) {
      ny = 20;
    }
    nx = Math.round(nx);
    ny = Math.round(ny);
    surfaces = [];
    for (x = o = 0, ref3 = nx; 0 <= ref3 ? o < ref3 : o > ref3; x = 0 <= ref3 ? ++o : --o) {
      column = [];
      for (y = u = 0, ref4 = ny; 0 <= ref4 ? u < ref4 : u > ref4; y = 0 <= ref4 ? ++u : --u) {
        pts0 = [P(x, y), P(x + 1, y - 0.5), P(x + 1, y + 0.5)];
        pts1 = [P(x, y), P(x + 1, y + 0.5), P(x, y + 1)];
        ref5 = [pts0, pts1];
        for (l1 = 0, len1 = ref5.length; l1 < len1; l1++) {
          pts = ref5[l1];
          for (m1 = 0, len2 = pts.length; m1 < len2; m1++) {
            p = pts[m1];
            p.x *= EQUILATERAL_TRIANGLE_ALTITUDE;
            p.y += x % 2 === 0 ? 0.5 : 0;
          }
          column.push(pts);
        }
      }
      if (x % 2 !== 0) {
        ref6 = column[0];
        for (o1 = 0, len3 = ref6.length; o1 < len3; o1++) {
          p = ref6[o1];
          p.y += ny;
        }
        column.push(column.shift());
      }
      surfaces = surfaces.concat(column);
    }
    return new Shape('patch', surfaces.map(function (s) {
      return new Surface(s);
    }));
  },
  text: function (text, surfaceOptions) {
    var key, surface, val;
    if (surfaceOptions == null) {
      surfaceOptions = {};
    }
    surface = new Surface(Affine.ORTHONORMAL_BASIS(), Painters.text);
    surface.text = text;
    for (key in surfaceOptions) {
      val = surfaceOptions[key];
      surface[key] = val;
    }
    return new Shape('text', [surface]);
  },
  extrude: function (points, offset) {
    var back, front, i, len, o, p, ref3, surfaces;
    surfaces = [];
    front = new Surface((function () {
      var len1, o, results;
      results = [];
      for (o = 0, len1 = points.length; o < len1; o++) {
        p = points[o];
        results.push(p.copy());
      }
      return results;
    })());
    back = new Surface((function () {
      var len1, o, results;
      results = [];
      for (o = 0, len1 = points.length; o < len1; o++) {
        p = points[o];
        results.push(p.add(offset));
      }
      return results;
    })());
    for (i = o = 1, ref3 = points.length; 1 <= ref3 ? o < ref3 : o > ref3; i = 1 <= ref3 ? ++o : --o) {
      surfaces.push(new Surface([front.points[i - 1].copy(), back.points[i - 1].copy(), back.points[i].copy(), front.points[i].copy()]));
    }
    len = points.length;
    surfaces.push(new Surface([front.points[len - 1].copy(), back.points[len - 1].copy(), back.points[0].copy(), front.points[0].copy()]));
    back.points.reverse();
    surfaces.push(front);
    surfaces.push(back);
    return new Shape('extrusion', surfaces);
  },
  arrow: function (thickness, tailLength, tailWidth, headLength, headPointiness) {
    var htw, points;
    if (thickness == null) {
      thickness = 1;
    }
    if (tailLength == null) {
      tailLength = 1;
    }
    if (tailWidth == null) {
      tailWidth = 1;
    }
    if (headLength == null) {
      headLength = 1;
    }
    if (headPointiness == null) {
      headPointiness = 0;
    }
    htw = tailWidth / 2;
    points = [P(0, 0, 0), P(headLength + headPointiness, 1, 0), P(headLength, htw, 0), P(headLength + tailLength, htw, 0), P(headLength + tailLength, -htw, 0), P(headLength, -htw, 0), P(headLength + headPointiness, -1, 0)];
    return Shapes.extrude(points, P(0, 0, thickness));
  },
  path: function (points) {
    return new Shape('path', [new Surface(points)]);
  },
  custom: function (s) {
    var f, len1, o, p, ref3, surfaces;
    surfaces = [];
    ref3 = s.surfaces;
    for (o = 0, len1 = ref3.length; o < len1; o++) {
      f = ref3[o];
      surfaces.push(new Surface((function () {
        var len2, results, u;
        results = [];
        for (u = 0, len2 = f.length; u < len2; u++) {
          p = f[u];
          results.push(P(p));
        }
        return results;
      })()));
    }
    return new Shape('custom', surfaces);
  },
  mapPointsToSurfaces: function (points, coordinateMap) {
    var c, coords, len1, o, spts, surfaces;
    surfaces = [];
    for (o = 0, len1 = coordinateMap.length; o < len1; o++) {
      coords = coordinateMap[o];
      spts = (function () {
        var len2, results, u;
        results = [];
        for (u = 0, len2 = coords.length; u < len2; u++) {
          c = coords[u];
          results.push(points[c].copy());
        }
        return results;
      })();
      surfaces.push(new Surface(spts));
    }
    return surfaces;
  },
  _subdivideTriangles: function (triangles) {
    var len1, newTriangles, o, tri, v01, v12, v20;
    newTriangles = [];
    for (o = 0, len1 = triangles.length; o < len1; o++) {
      tri = triangles[o];
      v01 = tri[0].copy().add(tri[1]).normalize();
      v12 = tri[1].copy().add(tri[2]).normalize();
      v20 = tri[2].copy().add(tri[0]).normalize();
      newTriangles.push([tri[0], v01, v20]);
      newTriangles.push([tri[1], v12, v01]);
      newTriangles.push([tri[2], v20, v12]);
      newTriangles.push([v01, v12, v20]);
    }
    return newTriangles;
  }
};

export class MocapModel {
  frames: any
  frameDelay: any
  model: any
  constructor(model1, frames1, frameDelay1) {
    this.model = model1;
    this.frames = frames1;
    this.frameDelay = frameDelay1;
  }

  MocapapplyFrameTransforms(frameIndex) {
    var frame, len1, o, transform;
    frame = this.frames[frameIndex];
    for (o = 0, len1 = frame.length; o < len1; o++) {
      transform = frame[o];
      transform.shape.reset().transform(transform.transform);
    }
    return (frameIndex + 1) % this.frames.length;
  };



}

export class MocapAnimator extends Animator {

  frameIndex: any
  _generateFrameTransforms: any
  _applyChannelTransform: any
  mocap: any
  frameDelay: any
  renderFrame: any
  bvh: any
  _attachJoint: any
  constructor(mocap) {
    super();
    this.mocap = mocap;

    this.frameIndex = 0;
    this.frameDelay = this.mocap.frameDelay;
    this.onFrame(this.renderFrame);
  }

  MocaprenderFrame() {
    return this.frameIndex = this.mocap.applyFrameTransforms(this.frameIndex);
  };



}

export class Mocap {
  bvh: any;
  static DEFAULT_SHAPE_FACTORY(joint, endpoint) {
    return Shapes.pipe(P(), endpoint);
  };

  static parse(source) {
    //return new Mocap(BvhParser.parse(source));
  };

  frames: any
  frameDelay: any
  model: any
  constructor(bvh) {
    this.bvh = bvh;
  }

  createMocapModel(shapeFactory) {
    var frames, joints, model;
    if (shapeFactory == null) {
      shapeFactory = Mocap.DEFAULT_SHAPE_FACTORY;
    }
    model = new Model();
    joints = [];
    this._attachJoint(model, this.bvh.root, joints, shapeFactory);
    frames = this.bvh.motion.frames.map((function (_this) {
      return function (frame) {
        return _this._generateFrameTransforms(frame, joints);
      };
    })(this));
    return new MocapModel(model, frames, this.bvh.motion.frameTime * 1000);
  };

  _generateFrameTransforms(frame, joints) {
    var fi, transforms;
    fi = 0;
    transforms = joints.map((function (_this) {
      return function (joint) {
        var ai, m;
        m = M();
        ai = joint.channels.length;
        while (ai > 0) {
          ai -= 1;
          _this._applyChannelTransform(joint.channels[ai], m, frame[fi + ai]);
        }
        fi += joint.channels.length;
        m.multiply(joint.offset);
        return {
          shape: joint.shape,
          transform: m
        };
      };
    })(this));
    return transforms;
  };

  _applyChannelTransform(channel, m, v) {
    switch (channel) {
      case 'Xposition':
        m.translate(v, 0, 0);
        break;
      case 'Yposition':
        m.translate(0, v, 0);
        break;
      case 'Zposition':
        m.translate(0, 0, v);
        break;
      case 'Xrotation':
        m.rotx(v * Math.PI / 180.0);
        break;
      case 'Yrotation':
        m.roty(v * Math.PI / 180.0);
        break;
      case 'Zrotation':
        m.rotz(v * Math.PI / 180.0);
    }
    return m;
  };

  _attachJoint(model, joint, joints, shapeFactory) {
    var child, childShapes, len1, o, offset, p, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
    offset = M().translate((ref3 = joint.offset) != null ? ref3.x : void 0, (ref4 = joint.offset) != null ? ref4.y : void 0, (ref5 = joint.offset) != null ? ref5.z : void 0);
    model.transform(offset);
    if (joint.channels != null) {
      joints.push({
        shape: model,
        offset: offset,
        channels: joint.channels
      });
    }
    if (joint.joints != null) {
      childShapes = model.append();
      ref6 = joint.joints;
      for (o = 0, len1 = ref6.length; o < len1; o++) {
        child = ref6[o];
        p = P((ref7 = child.offset) != null ? ref7.x : void 0, (ref8 = child.offset) != null ? ref8.y : void 0, (ref9 = child.offset) != null ? ref9.z : void 0);
        childShapes.add(shapeFactory(joint, p));
        if (child.type === 'JOINT') {
          this._attachJoint(childShapes.append(), child, joints, shapeFactory);
        }
      }
    }
  };



}

export class ObjParser {
  commands: any
  faces: any
  vertices: any
  constructor() {
    this.vertices = [];
    this.faces = [];
    this.commands = {
      v: (function (_this) {
        return function (data) {
          return _this.vertices.push(data.map(function (d) {
            return parseFloat(d);
          }));
        };
      })(this),
      f: (function (_this) {
        return function (data) {
          return _this.faces.push(data.map(function (d) {
            return parseInt(d);
          }));
        };
      })(this)
    };
  }

  parse(contents) {
    var command, data, len1, line, o, ref3, results;
    ref3 = contents.split(/[\r\n]+/);
    results = [];
    for (o = 0, len1 = ref3.length; o < len1; o++) {
      line = ref3[o];
      data = line.trim().split(/[ ]+/);
      if (data.length < 2) {
        continue;
      }
      command = data.slice(0, 1)[0];
      data = data.slice(1);
      if (command.charAt(0) === '#') {
        continue;
      }
      if (this.commands[command] == null) {
        console.log("OBJ Parser: Skipping unknown command '" + command + "'");
        continue;
      }
      results.push(this.commands[command](data));
    }
    return results;
  };

  mapFacePoints(faceMap) {
    return this.faces.map((function (_this) {
      return function (face) {
        var points;
        points = face.map(function (v) {
          return P(_this.vertices[v - 1]);
        });
        return faceMap.call(_this, points);
      };
    })(this));
  };



}

export let Projections = {
  perspectiveFov: function (fovyInDegrees, front) {
    var tan;
    if (fovyInDegrees == null) {
      fovyInDegrees = 50;
    }
    if (front == null) {
      front = 1;
    }
    tan = front * Math.tan(fovyInDegrees * Math.PI / 360.0);
    return Projections.perspective(-tan, tan, -tan, tan, front, 2 * front);
  },
  perspective: function (left = -1, right = 1, bottom = -1, top = 1, near = 1, far = 100) {
    var dx, dy, dz, m, near2;
    if (left == null) {
      left = -1;
    }
    if (right == null) {
      right = 1;
    }
    if (bottom == null) {
      bottom = -1;
    }
    if (top == null) {
      top = 1;
    }
    if (near == null) {
      near = 1;
    }
    if (far == null) {
      far = 100;
    }
    near2 = 2 * near;
    dx = right - left;
    dy = top - bottom;
    dz = far - near;
    m = new Array(16);
    m[0] = near2 / dx;
    m[1] = 0.0;
    m[2] = (right + left) / dx;
    m[3] = 0.0;
    m[4] = 0.0;
    m[5] = near2 / dy;
    m[6] = (top + bottom) / dy;
    m[7] = 0.0;
    m[8] = 0.0;
    m[9] = 0.0;
    m[10] = -(far + near) / dz;
    m[11] = -(far * near2) / dz;
    m[12] = 0.0;
    m[13] = 0.0;
    m[14] = -1.0;
    m[15] = 0.0;
    return M(m);
  },
  ortho: function (left, right, bottom, top, near, far) {
    var dx, dy, dz, m, near2;
    if (left == null) {
      left = -1;
    }
    if (right == null) {
      right = 1;
    }
    if (bottom == null) {
      bottom = -1;
    }
    if (top == null) {
      top = 1;
    }
    if (near == null) {
      near = 1;
    }
    if (far == null) {
      far = 100;
    }
    near2 = 2 * near;
    dx = right - left;
    dy = top - bottom;
    dz = far - near;
    m = new Array(16);
    m[0] = 2 / dx;
    m[1] = 0.0;
    m[2] = 0.0;
    m[3] = (right + left) / dx;
    m[4] = 0.0;
    m[5] = 2 / dy;
    m[6] = 0.0;
    m[7] = -(top + bottom) / dy;
    m[8] = 0.0;
    m[9] = 0.0;
    m[10] = -2 / dz;
    m[11] = -(far + near) / dz;
    m[12] = 0.0;
    m[13] = 0.0;
    m[14] = 0.0;
    m[15] = 1.0;
    return M(m);
  }
};

export let Viewports = {
  center: function (width = 500, height= 500, x = 0, y = 0) {
    var postscale, prescale;
    if (width == null) {
      width = 500;
    }
    if (height == null) {
      height = 500;
    }
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    prescale = M().translate(-x, -y, -height).scale(1 / width, 1 / height, 1 / height);
    postscale = M().scale(width, -height, height).translate(x + width / 2, y + height / 2, height);
    return {
      prescale: prescale,
      postscale: postscale
    };
  },
  origin: function (width = 500, height = 500, x = 0, y = 0) {
    var postscale, prescale;
    if (width == null) {
      width = 500;
    }
    if (height == null) {
      height = 500;
    }
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    prescale = M().translate(-x, -y, -1).scale(1 / width, 1 / height, 1 / height);
    postscale = M().scale(width, -height, height).translate(x, y);
    return {
      prescale: prescale,
      postscale: postscale
    };
  }
};

export class Camera extends Transformable {

  defaults = {
    projection: Projections.perspective()
  };

  fractionalPoints: any
  render: any
  viewport: any
  _renderSurface: any
  _renderModelCache: any
  camera: any
  cullBackfaces: any
  cache: any
  flushCache: any
  model: any
  shader: any
  constructor(options = {}) {
    super();
    Util.defaults(this, options, this.defaults);
  }



}

export class Scene {
  cache: any;
  model: any;
  viewport: any;
  camera: any;
  _renderModelCache: {};
  defaults() {
    return {
      model: new Model(),
      camera: new Camera(),
      viewport: Viewports.origin(1, 1),
      shader: Shaders.phong(),
      cullBackfaces: true,
      fractionalPoints: false,
      cache: true
    };
  };

  scene: any
  width: any
  fill: any
  height: any
  elementFactory: any
  _paint: any
  _svgTag: any
  _attributes: any
  cullBackfaces: any
  fractionalPoints: any
  shader: any
  constructor(options = {}) {


    Util.defaults(this, options, this.defaults());
    this._renderModelCache = {};
  }

  render() {
    var projection, renderModels, viewport;
    projection = this.camera.m.copy().multiply(this.viewport.prescale).multiply(this.camera.projection);
    viewport = this.viewport.postscale;
    renderModels = [];
    this.model.eachRenderable(function (light, transform) {
      return new LightRenderModel(light, transform);
    }, (function (_this) {
      return function (shape, lights, transform) {
        var len1, len2, o, p, ref3, ref4, ref5, ref6, renderModel, results, surface, u;
        ref3 = shape.surfaces;
        results = [];
        for (o = 0, len1 = ref3.length; o < len1; o++) {
          surface = ref3[o];
          renderModel = _this._renderSurface(surface, transform, projection, viewport);
          if ((!_this.cullBackfaces || !surface.cullBackfaces || renderModel.projected.normal.z < 0) && renderModel.inFrustrum) {
            renderModel.fill = (ref4 = surface.fillMaterial) != null ? ref4.render(lights, _this.shader, renderModel.transformed) : void 0;
            renderModel.stroke = (ref5 = surface.strokeMaterial) != null ? ref5.render(lights, _this.shader, renderModel.transformed) : void 0;
            if (_this.fractionalPoints !== true) {
              ref6 = renderModel.projected.points;
              for (u = 0, len2 = ref6.length; u < len2; u++) {
                p = ref6[u];
                p.round();
              }
            }
            results.push(renderModels.push(renderModel));
          } else {
            results.push(void 0);
          }
        }
        return results;
      };
    })(this));
    renderModels.sort(function (a, b) {
      return b.projected.barycenter.z - a.projected.barycenter.z;
    });
    return renderModels;
  };

  _renderSurface(surface, transform, projection, viewport) {
    var renderModel;
    if (!this.cache) {
      return new RenderModel(surface, transform, projection, viewport);
    }
    renderModel = this._renderModelCache[surface.id];
    if (renderModel == null) {
      renderModel = this._renderModelCache[surface.id] = new RenderModel(surface, transform, projection, viewport);
    } else {
      renderModel.update(transform, projection, viewport);
    }
    return renderModel;
  };

  flushCache() {
    return this._renderModelCache = {};
  };



}

export class Grad {
  x: any
  z: any
  y: any
  constructor(x4, y4, z4) {
    this.x = x4;
    this.y = y4;
    this.z = z4;
  }

  dot(x, y, z) {
    return this.x * x + this.y * y + this.z * z;
  };



}

let grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0), new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1), new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];

let SIMPLEX_PERMUTATIONS_TABLE = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];

let F3 = 1 / 3;

let G3 = 1 / 6;

export class Simplex3D {
  gradP: any
  perm: any
  constructor(seed) {
    if (seed == null) {
      seed = 0;
    }
    this.perm = new Array(512);
    this.gradP = new Array(512);
    this.seed(seed);
  }

  seed(seed) {
    var i, o, results, v;
    if (seed > 0 && seed < 1) {
      seed *= 65536;
    }
    seed = Math.floor(seed);
    if (seed < 256) {
      seed |= seed << 8;
    }
    results = [];
    for (i = o = 0; o < 256; i = ++o) {
      v = 0;
      if (i & 1) {
        v = SIMPLEX_PERMUTATIONS_TABLE[i] ^ (seed & 255);
      } else {
        v = SIMPLEX_PERMUTATIONS_TABLE[i] ^ ((seed >> 8) & 255);
      }
      this.perm[i] = this.perm[i + 256] = v;
      results.push(this.gradP[i] = this.gradP[i + 256] = grad3[v % 12]);
    }
    return results;
  };

  noise(x, y, z) {
    var gi0, gi1, gi2, gi3, i, i1, i2, j, j1, j2, k, k1, k2, n0, n1, n2, n3, s, t, t0, t1, t2, t3, x0, x1, x2, x3, y0, y1, y2, y3, z0, z1, z2, z3;
    s = (x + y + z) * F3;
    i = Math.floor(x + s);
    j = Math.floor(y + s);
    k = Math.floor(z + s);
    t = (i + j + k) * G3;
    x0 = x - i + t;
    y0 = y - j + t;
    z0 = z - k + t;
    if (x0 >= y0) {
      if (y0 >= z0) {
        i1 = 1;
        j1 = 0;
        k1 = 0;
        i2 = 1;
        j2 = 1;
        k2 = 0;
      } else if (x0 >= z0) {
        i1 = 1;
        j1 = 0;
        k1 = 0;
        i2 = 1;
        j2 = 0;
        k2 = 1;
      } else {
        i1 = 0;
        j1 = 0;
        k1 = 1;
        i2 = 1;
        j2 = 0;
        k2 = 1;
      }
    } else {
      if (y0 < z0) {
        i1 = 0;
        j1 = 0;
        k1 = 1;
        i2 = 0;
        j2 = 1;
        k2 = 1;
      } else if (x0 < z0) {
        i1 = 0;
        j1 = 1;
        k1 = 0;
        i2 = 0;
        j2 = 1;
        k2 = 1;
      } else {
        i1 = 0;
        j1 = 1;
        k1 = 0;
        i2 = 1;
        j2 = 1;
        k2 = 0;
      }
    }
    x1 = x0 - i1 + G3;
    y1 = y0 - j1 + G3;
    z1 = z0 - k1 + G3;
    x2 = x0 - i2 + 2 * G3;
    y2 = y0 - j2 + 2 * G3;
    z2 = z0 - k2 + 2 * G3;
    x3 = x0 - 1 + 3 * G3;
    y3 = y0 - 1 + 3 * G3;
    z3 = z0 - 1 + 3 * G3;
    i &= 0xFF;
    j &= 0xFF;
    k &= 0xFF;
    gi0 = this.gradP[i + this.perm[j + this.perm[k]]];
    gi1 = this.gradP[i + i1 + this.perm[j + j1 + this.perm[k + k1]]];
    gi2 = this.gradP[i + i2 + this.perm[j + j2 + this.perm[k + k2]]];
    gi3 = this.gradP[i + 1 + this.perm[j + 1 + this.perm[k + 1]]];
    t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0;
    if (t0 < 0) {
      n0 = 0;
    } else {
      t0 *= t0;
      n0 = t0 * t0 * gi0.dot(x0, y0, z0);
    }
    t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1;
    if (t1 < 0) {
      n1 = 0;
    } else {
      t1 *= t1;
      n1 = t1 * t1 * gi1.dot(x1, y1, z1);
    }
    t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2;
    if (t2 < 0) {
      n2 = 0;
    } else {
      t2 *= t2;
      n2 = t2 * t2 * gi2.dot(x2, y2, z2);
    }
    t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3;
    if (t3 < 0) {
      n3 = 0;
    } else {
      t3 *= t3;
      n3 = t3 * t3 * gi3.dot(x3, y3, z3);
    }
    return 32 * (n0 + n1 + n2 + n3);
  }
}